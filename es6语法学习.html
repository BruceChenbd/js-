<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>es6学习</title>
</head>
<body>
    <script>
        // 1.let生命的变量只在他所在的代码块种有效。
       {
           let a=10;
           var b=1;
       }
        //    console.log(b); // 1
        //    console.log(a); // is not defined
       for(let i=0;i<10;i++){

       }
        //    console.log(i) is not defined
        var a = [];
        for (var i = 0; i < 10; i++) {
        a[i] = function () {
            console.log(i);
        };
        }
        a[6](); // 10 var 声明的变量i在全局内都有效，所以只有一个变量i

        var a = [];
        for (let i = 0; i < 10; i++) {
        a[i] = function () {
            console.log(i);
        };
        }
        a[6](); //6 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i都是一个新的变量

        for(let i=0;i<3;i++){
            let i='cbd';
            console.log(i)
        }
        // abc(3) for循环独特之处，设置循环变量的那部分是一个父级作用域，而循环体内部是一个单独的子作用域

        // 2.不存在变量提升
        // var的情况
        // console.log(foo); // undefined
        var foo = 2;

        //let的情况
        // console.log(bar); // 报错
        let bar = 2;

        // 3.暂时性死区（TDZ）
        var tmp=123;
        if(true){
            // tmp = 'abc'; // 报错
            let tmp; 
        }
        // es6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭的作用域
        if (true) {
            // TDZ开始
            // tmp = 'abc'; // ReferenceError
            // console.log(tmp); // ReferenceError

            let tmp; // TDZ结束
            console.log(tmp); // undefined

            tmp = 123;
            console.log(tmp); // 123
        }

        // 4.不允许重复声明
        // 5.为什么需要块级作用域
        // ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。
        // 第一种场景，内层变量可能会覆盖外层变量。
        var tmp = new Date();
        function f(){
            console.log(tmp)
            if(false){
                var tmp = 'hello world'
            }
        }
        f() // undefined
        // 第二种场景，用来计数的循环变量泄露为全局变量
        var s = 'hello';
        for(var i=0;i<s.length;i++){
            console.log(s[i]);
        }
        console.log(i)

        // 1.const声明一个只读的常量。一旦声明，常量的值就不得改变。
        // 2.const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。
        // 本质上cosnt保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
    </script>
</body>
</html>